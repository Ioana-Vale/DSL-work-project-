/*
 * generated by Xtext 2.35.0
 */
package org.xtext.example.mydsl.tests

import com.google.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.extensions.InjectionExtension
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.^extension.ExtendWith
import org.xtext.example.mydsl.myDsl.DomainModel
import org.eclipse.emf.common.util.TreeIterator
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.ide.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.testing.validation.ValidationTestHelper
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import java.util.List
import com.sun.tools.javac.util.Assert
import javax.tools.Diagnostic

@ExtendWith(InjectionExtension)
@InjectWith(MyDslInjectorProvider)

class MyDslParsingTest {
	@Inject
	ParseHelper<DomainModel> parseHelper
	 @Inject
	 ValidationTestHelper validationHelper

@Test
	def void loadModel20() throws Exception {
		val result = parseHelper.parse("intiger");
		Assertions.assertNotNull(result);
		val errors = result.eResource.errors
		//List<Diagnostic> errors = result.eResource().getErrors();
		Assertions.assertFalse(errors.exists[error|error.getMessage.contains("Type mismatch")],
			"Expected type mismatch error but none was found."
	
	)
	}
    // Test for unused parameters
    @Test
    def void testUnusedParameters() {
        val result = parseHelper.parse('''
            function process(x, y) {
                console.log(x); // Used
                // y is unused
            }
        ''');

       val issues=validationHelper.validate(result)
		Assertions.assertFalse(issues.isEmpty,"Expected erors but found none.")
		issues.forEach[issue|println(issue.getMessage)]
		Assertions.assertTrue(issues.exists[issue|issue.getMessage.contains("Type mismatch")],
			"Expected type mismatch error but none was found."
		)
    }

    
    @Test
    def void testInconsistentTypeUsage() {
        val result = parseHelper.parse('''
            var a: int = 5;
            a = "string"; // Invalid type assignment
        ''');

       val issues=validationHelper.validate(result)
		Assertions.assertFalse(issues.isEmpty,"Expected erors but found none.")
		issues.forEach[issue|println(issue.getMessage)]
		Assertions.assertTrue(issues.exists[issue|issue.getMessage.contains("Type mismatch")],
			"Expected type mismatch error but none was found."
		)
    }
	@Test
	def void loadModel() {
		val result = parseHelper.parse('''
			var x = 10;
			let y = 20;
			const z = 30;
		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}
	
	@Test
	def void loadModel14() {
		val result = parseHelper.parse('''
		String Ana="ana";
			1-Ana;
		''') 
		val issues=validationHelper.validate(result)
		Assertions.assertTrue(issues.isEmpty,"Expected erors but found none.")
		issues.forEach[issue|println(issue.getMessage)]
		Assertions.assertFalse(issues.exists[issue|issue.getMessage.contains("Type mismatch")],
			"Expected type mismatch error but none was found."
		)
	}
		
	@Test
	def void loadModel1() {
		val result = parseHelper.parse('''
				x + y;
				y * z;		''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}
	
	@Test
	def void loadModel2() {
		val result = parseHelper.parse('''
				x += 5;
				y -= 3;
				z *= 2;	''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}
	
	@Test
	def void loadModel3() {
		val result = parseHelper.parse('''
			if (x > 10) {
			    console.log(x);
			} else {
			    console.log(y);
			}	''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}
	
	@Test
	def void loadModel4() {
		val result = parseHelper.parse('''
		for (i = 0; i < 10; i++) {
			    console.log(i);
						}	''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}
	
	@Test
	def void loadModel5() {
		val result = parseHelper.parse('''
		while (x < 20) {
			x++;
					}	''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}
	
	@Test
	def void loadModel6() {
		val result = parseHelper.parse('''
					do {
					    x--;
					} while (x > 0);	''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}
	
	
	@Test
	def void loadModel7() {
		val result = parseHelper.parse('''
		for (i = 0; i < 10; i++) {
			    console.log(i);
						}	''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}
	
	@Test
	def void loadModel8() {
		val result = parseHelper.parse('''
		++x;
		--y;	
		x++;
		y--;''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}
	
	@Test
	def void loadModel9() {
		val result = parseHelper.parse('''
		switch (x) {
					    case 1:
					        console.log("One");
					        break;
					    case 2:
					        console.log("Two");
					        break;
					    default:
					        console.log("Other");
					}''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}
	
	@Test
	def void loadModel10() {
		val result = parseHelper.parse('''
		function add(a, b) {
					    return a + b;
					}''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}
	
	@Test
	def void loadModel17() {
		val result = parseHelper.parse('''
		console.log("Hello, World!");''')
		Assertions.assertNotNull(result)
		val errors = result.eResource.errors
		Assertions.assertTrue(errors.isEmpty, '''Unexpected errors: «errors.join(", ")»''')
	}	
	
@Test
def void testVariableScopeInValid() {
    val result = parseHelper.parse('''
        var x = 10;
        function fcn(){
            var y = 20;
            console.log(x); // valid
            console.log(y); // valid
        }
        console.log(x); // valid
         console.log(y); // invalid, pentru că `y` nu trebuie să fie accesibil aici
    ''')

    val issues=validationHelper.validate(result)
		Assertions.assertFalse(issues.isEmpty,"Expected erors but found none.")
		issues.forEach[issue|println(issue.getMessage)]
		Assertions.assertFalse(issues.exists[issue|issue.getMessage.contains("Type mismatch")],
			"Expected type mismatch error but none was found."
		)
}

@Test
def void testVariableScopeValid() {
    val result = parseHelper.parse('''
    
        var x = 10;
        function fcn()
        {
            var y = 20;
            console.log(x); // valid
            console.log(y); // valid
        }
        console.log(x); // valid
        
    ''')

   val issues=validationHelper.validate(result)
		Assertions.assertTrue(issues.isEmpty,"Expected erors but found none.")
		issues.forEach[issue|println(issue.getMessage)]
		Assertions.assertFalse(issues.exists[issue|issue.getMessage.contains("Type mismatch")],
			"Expected type mismatch error but none was found."
		)

}

@Test
def void testFunctionScopeInvalid() {
    val result = parseHelper.parse('''
function outerFunction() {
            var a = 10;
            function innerFunction() {
                var b = 20;
                console.log(a); // valid, a este accesibil în innerFunction
                console.log(b); // valid, b este accesibil în innerFunction
            }
            innerFunction();
            console.log(a); // valid, a este accesibil în outerFunction
            console.log(b); // invalid, b nu este accesibil în outerFunction
        }
        console.log(a); // invalid, a nu este accesibil în afara outerFunction
        outerFunction();    ''')

    val issues=validationHelper.validate(result)
		Assertions.assertFalse(issues.isEmpty,"Expected erors but found none.")
		issues.forEach[issue|println(issue.getMessage)]
		Assertions.assertFalse(issues.exists[issue|issue.getMessage.contains("Type mismatch")],
			"Expected type mismatch error but none was found."
		)
}

@Test
def void testFunctionScopeValid() {
    val result = parseHelper.parse('''
        function outerFunction() {
                    var a = 10;
                    function innerFunction() {
                        var b = 20;
                        console.log(a); // valid, a este accesibil în innerFunction
                        console.log(b); // valid, b este accesibil în innerFunction
                    }
                    innerFunction();                   
                }
                outerFunction();
    ''')

    val issues=validationHelper.validate(result)
		Assertions.assertTrue(issues.isEmpty,"Expected erors but found none.")
		issues.forEach[issue|println(issue.getMessage)]
		Assertions.assertFalse(issues.exists[issue|issue.getMessage.contains("Type mismatch")],
			"Expected type mismatch error but none was found."
		)
}	
}

