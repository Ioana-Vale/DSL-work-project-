/**
 * generated by Xtext 2.35.0
 */
package org.xtext.example.mydsl.tests;

import com.google.inject.Inject;
import java.util.List;
import java.util.function.Consumer;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.testing.InjectWith;
import org.eclipse.xtext.testing.extensions.InjectionExtension;
import org.eclipse.xtext.testing.util.ParseHelper;
import org.eclipse.xtext.testing.validation.ValidationTestHelper;
import org.eclipse.xtext.validation.Issue;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.xtext.example.mydsl.myDsl.DomainModel;

@ExtendWith(InjectionExtension.class)
@InjectWith(MyDslInjectorProvider.class)
@SuppressWarnings("all")
public class MyDslParsingTest {
  @Inject
  private ParseHelper<DomainModel> parseHelper;

  @Inject
  private ValidationTestHelper validationHelper;

  @Test
  public void loadModel20() throws Exception {
    final DomainModel result = this.parseHelper.parse("intiger");
    Assertions.assertNotNull(result);
    final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
    final Function1<Resource.Diagnostic, Boolean> _function = (Resource.Diagnostic error) -> {
      return Boolean.valueOf(error.getMessage().contains("Type mismatch"));
    };
    Assertions.assertFalse(IterableExtensions.<Resource.Diagnostic>exists(errors, _function), 
      "Expected type mismatch error but none was found.");
  }

  @Test
  public void testUnusedParameters() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("function process(x, y) {");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("console.log(x); // Used");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("// y is unused");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      final DomainModel result = this.parseHelper.parse(_builder);
      final List<Issue> issues = this.validationHelper.validate(result);
      Assertions.assertFalse(issues.isEmpty(), "Expected erors but found none.");
      final Consumer<Issue> _function = (Issue issue) -> {
        InputOutput.<String>println(issue.getMessage());
      };
      issues.forEach(_function);
      final Function1<Issue, Boolean> _function_1 = (Issue issue) -> {
        return Boolean.valueOf(issue.getMessage().contains("Type mismatch"));
      };
      Assertions.assertTrue(IterableExtensions.<Issue>exists(issues, _function_1), 
        "Expected type mismatch error but none was found.");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void testInconsistentTypeUsage() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("var a: int = 5;");
      _builder.newLine();
      _builder.append("a = \"string\"; // Invalid type assignment");
      _builder.newLine();
      final DomainModel result = this.parseHelper.parse(_builder);
      final List<Issue> issues = this.validationHelper.validate(result);
      Assertions.assertFalse(issues.isEmpty(), "Expected erors but found none.");
      final Consumer<Issue> _function = (Issue issue) -> {
        InputOutput.<String>println(issue.getMessage());
      };
      issues.forEach(_function);
      final Function1<Issue, Boolean> _function_1 = (Issue issue) -> {
        return Boolean.valueOf(issue.getMessage().contains("Type mismatch"));
      };
      Assertions.assertTrue(IterableExtensions.<Issue>exists(issues, _function_1), 
        "Expected type mismatch error but none was found.");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void loadModel() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("var x = 10;");
      _builder.newLine();
      _builder.append("let y = 20;");
      _builder.newLine();
      _builder.append("const z = 30;");
      _builder.newLine();
      final DomainModel result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", ");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void loadModel14() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("String Ana=\"ana\";");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("1-Ana;");
      _builder.newLine();
      final DomainModel result = this.parseHelper.parse(_builder);
      final List<Issue> issues = this.validationHelper.validate(result);
      Assertions.assertTrue(issues.isEmpty(), "Expected erors but found none.");
      final Consumer<Issue> _function = (Issue issue) -> {
        InputOutput.<String>println(issue.getMessage());
      };
      issues.forEach(_function);
      final Function1<Issue, Boolean> _function_1 = (Issue issue) -> {
        return Boolean.valueOf(issue.getMessage().contains("Type mismatch"));
      };
      Assertions.assertFalse(IterableExtensions.<Issue>exists(issues, _function_1), 
        "Expected type mismatch error but none was found.");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void loadModel1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("x + y;");
      _builder.newLine();
      _builder.append("y * z;\t\t");
      final DomainModel result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", ");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void loadModel2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("x += 5;");
      _builder.newLine();
      _builder.append("y -= 3;");
      _builder.newLine();
      _builder.append("z *= 2;\t");
      final DomainModel result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", ");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void loadModel3() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("if (x > 10) {");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("console.log(x);");
      _builder.newLine();
      _builder.append("} else {");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("console.log(y);");
      _builder.newLine();
      _builder.append("}\t");
      final DomainModel result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", ");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void loadModel4() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("for (i = 0; i < 10; i++) {");
      _builder.newLine();
      _builder.append("\t    ");
      _builder.append("console.log(i);");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("}\t");
      final DomainModel result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", ");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void loadModel5() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("while (x < 20) {");
      _builder.newLine();
      _builder.append("\t");
      _builder.append("x++;");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}\t");
      final DomainModel result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", ");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void loadModel6() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("do {");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("x--;");
      _builder.newLine();
      _builder.append("} while (x > 0);\t");
      final DomainModel result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", ");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void loadModel7() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("for (i = 0; i < 10; i++) {");
      _builder.newLine();
      _builder.append("\t    ");
      _builder.append("console.log(i);");
      _builder.newLine();
      _builder.append("\t\t\t\t");
      _builder.append("}\t");
      final DomainModel result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", ");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void loadModel8() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("++x;");
      _builder.newLine();
      _builder.append("--y;\t");
      _builder.newLine();
      _builder.append("x++;");
      _builder.newLine();
      _builder.append("y--;");
      final DomainModel result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", ");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void loadModel9() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("switch (x) {");
      _builder.newLine();
      _builder.append("\t\t\t    ");
      _builder.append("case 1:");
      _builder.newLine();
      _builder.append("\t\t\t        ");
      _builder.append("console.log(\"One\");");
      _builder.newLine();
      _builder.append("\t\t\t        ");
      _builder.append("break;");
      _builder.newLine();
      _builder.append("\t\t\t    ");
      _builder.append("case 2:");
      _builder.newLine();
      _builder.append("\t\t\t        ");
      _builder.append("console.log(\"Two\");");
      _builder.newLine();
      _builder.append("\t\t\t        ");
      _builder.append("break;");
      _builder.newLine();
      _builder.append("\t\t\t    ");
      _builder.append("default:");
      _builder.newLine();
      _builder.append("\t\t\t        ");
      _builder.append("console.log(\"Other\");");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      final DomainModel result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", ");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void loadModel10() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("function add(a, b) {");
      _builder.newLine();
      _builder.append("\t\t\t    ");
      _builder.append("return a + b;");
      _builder.newLine();
      _builder.append("\t\t\t");
      _builder.append("}");
      final DomainModel result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", ");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void loadModel17() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("console.log(\"Hello, World!\");");
      final DomainModel result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", ");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void testVariableScopeInValid() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("var x = 10;");
      _builder.newLine();
      _builder.append("function fcn(){");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("var y = 20;");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("console.log(x); // valid");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("console.log(y); // valid");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.append("console.log(x); // valid");
      _builder.newLine();
      _builder.append(" ");
      _builder.append("console.log(y); // invalid, pentru că `y` nu trebuie să fie accesibil aici");
      _builder.newLine();
      final DomainModel result = this.parseHelper.parse(_builder);
      final List<Issue> issues = this.validationHelper.validate(result);
      Assertions.assertFalse(issues.isEmpty(), "Expected erors but found none.");
      final Consumer<Issue> _function = (Issue issue) -> {
        InputOutput.<String>println(issue.getMessage());
      };
      issues.forEach(_function);
      final Function1<Issue, Boolean> _function_1 = (Issue issue) -> {
        return Boolean.valueOf(issue.getMessage().contains("Type mismatch"));
      };
      Assertions.assertFalse(IterableExtensions.<Issue>exists(issues, _function_1), 
        "Expected type mismatch error but none was found.");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void testVariableScopeValid() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("    ");
      _builder.newLine();
      _builder.append("var x = 10;");
      _builder.newLine();
      _builder.append("function fcn()");
      _builder.newLine();
      _builder.append("{");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("var y = 20;");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("console.log(x); // valid");
      _builder.newLine();
      _builder.append("    ");
      _builder.append("console.log(y); // valid");
      _builder.newLine();
      _builder.append("}");
      _builder.newLine();
      _builder.append("console.log(x); // valid");
      _builder.newLine();
      _builder.newLine();
      final DomainModel result = this.parseHelper.parse(_builder);
      final List<Issue> issues = this.validationHelper.validate(result);
      Assertions.assertTrue(issues.isEmpty(), "Expected erors but found none.");
      final Consumer<Issue> _function = (Issue issue) -> {
        InputOutput.<String>println(issue.getMessage());
      };
      issues.forEach(_function);
      final Function1<Issue, Boolean> _function_1 = (Issue issue) -> {
        return Boolean.valueOf(issue.getMessage().contains("Type mismatch"));
      };
      Assertions.assertFalse(IterableExtensions.<Issue>exists(issues, _function_1), 
        "Expected type mismatch error but none was found.");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void testFunctionScopeInvalid() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("function outerFunction() {");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("var a = 10;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("function innerFunction() {");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("var b = 20;");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("console.log(a); // valid, a este accesibil în innerFunction");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("console.log(b); // valid, b este accesibil în innerFunction");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("innerFunction();");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("console.log(a); // valid, a este accesibil în outerFunction");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("console.log(b); // invalid, b nu este accesibil în outerFunction");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("console.log(a); // invalid, a nu este accesibil în afara outerFunction");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("outerFunction();    ");
      final DomainModel result = this.parseHelper.parse(_builder);
      final List<Issue> issues = this.validationHelper.validate(result);
      Assertions.assertFalse(issues.isEmpty(), "Expected erors but found none.");
      final Consumer<Issue> _function = (Issue issue) -> {
        InputOutput.<String>println(issue.getMessage());
      };
      issues.forEach(_function);
      final Function1<Issue, Boolean> _function_1 = (Issue issue) -> {
        return Boolean.valueOf(issue.getMessage().contains("Type mismatch"));
      };
      Assertions.assertFalse(IterableExtensions.<Issue>exists(issues, _function_1), 
        "Expected type mismatch error but none was found.");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void testFunctionScopeValid() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("function outerFunction() {");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("var a = 10;");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("function innerFunction() {");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("var b = 20;");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("console.log(a); // valid, a este accesibil în innerFunction");
      _builder.newLine();
      _builder.append("                ");
      _builder.append("console.log(b); // valid, b este accesibil în innerFunction");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("            ");
      _builder.append("innerFunction();                   ");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("}");
      _builder.newLine();
      _builder.append("        ");
      _builder.append("outerFunction();");
      _builder.newLine();
      final DomainModel result = this.parseHelper.parse(_builder);
      final List<Issue> issues = this.validationHelper.validate(result);
      Assertions.assertTrue(issues.isEmpty(), "Expected erors but found none.");
      final Consumer<Issue> _function = (Issue issue) -> {
        InputOutput.<String>println(issue.getMessage());
      };
      issues.forEach(_function);
      final Function1<Issue, Boolean> _function_1 = (Issue issue) -> {
        return Boolean.valueOf(issue.getMessage().contains("Type mismatch"));
      };
      Assertions.assertFalse(IterableExtensions.<Issue>exists(issues, _function_1), 
        "Expected type mismatch error but none was found.");
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
}
