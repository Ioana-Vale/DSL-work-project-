/**
 * generated by Xtext 2.35.0
 */
package org.xtext.example.mydsl.myDsl.util;

import org.eclipse.emf.common.notify.Adapter;
import org.eclipse.emf.common.notify.Notifier;

import org.eclipse.emf.common.notify.impl.AdapterFactoryImpl;

import org.eclipse.emf.ecore.EObject;

import org.xtext.example.mydsl.myDsl.AnonymousFunction;
import org.xtext.example.mydsl.myDsl.ArithmeticExpression;
import org.xtext.example.mydsl.myDsl.AugmentedAssignment;
import org.xtext.example.mydsl.myDsl.Block;
import org.xtext.example.mydsl.myDsl.Case;
import org.xtext.example.mydsl.myDsl.CharLiteral;
import org.xtext.example.mydsl.myDsl.ComparisonExpression;
import org.xtext.example.mydsl.myDsl.ConsoleLogStatement;
import org.xtext.example.mydsl.myDsl.Default;
import org.xtext.example.mydsl.myDsl.DoWhileLoop;
import org.xtext.example.mydsl.myDsl.DomainModel;
import org.xtext.example.mydsl.myDsl.ExponentiationExpression;
import org.xtext.example.mydsl.myDsl.Expression;
import org.xtext.example.mydsl.myDsl.ExpressionStatement;
import org.xtext.example.mydsl.myDsl.ForLoop;
import org.xtext.example.mydsl.myDsl.FunctionCall;
import org.xtext.example.mydsl.myDsl.FunctionDeclaration;
import org.xtext.example.mydsl.myDsl.FunctionReturn;
import org.xtext.example.mydsl.myDsl.IfStatement;
import org.xtext.example.mydsl.myDsl.Import;
import org.xtext.example.mydsl.myDsl.JoinFunctionCall;
import org.xtext.example.mydsl.myDsl.LogicalExpression;
import org.xtext.example.mydsl.myDsl.MultiplicationExpression;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.NotBoolean;
import org.xtext.example.mydsl.myDsl.NumberLiteral;
import org.xtext.example.mydsl.myDsl.PostfixOperator;
import org.xtext.example.mydsl.myDsl.PrefixOperator;
import org.xtext.example.mydsl.myDsl.SliceFunctionCall;
import org.xtext.example.mydsl.myDsl.SplitFunctionCall;
import org.xtext.example.mydsl.myDsl.Statement;
import org.xtext.example.mydsl.myDsl.StringLiteral;
import org.xtext.example.mydsl.myDsl.StringManipulationFunctionCall;
import org.xtext.example.mydsl.myDsl.StringManipulationStatement;
import org.xtext.example.mydsl.myDsl.SwitchStatement;
import org.xtext.example.mydsl.myDsl.ThrowStatement;
import org.xtext.example.mydsl.myDsl.TryCatchStatement;
import org.xtext.example.mydsl.myDsl.VariableDeclaration;
import org.xtext.example.mydsl.myDsl.VariableReference;
import org.xtext.example.mydsl.myDsl.WhileLoop;

/**
 * <!-- begin-user-doc -->
 * The <b>Adapter Factory</b> for the model.
 * It provides an adapter <code>createXXX</code> method for each class of the model.
 * <!-- end-user-doc -->
 * @see org.xtext.example.mydsl.myDsl.MyDslPackage
 * @generated
 */
public class MyDslAdapterFactory extends AdapterFactoryImpl
{
	/**
	 * The cached model package.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	protected static MyDslPackage modelPackage;

	/**
	 * Creates an instance of the adapter factory.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	public MyDslAdapterFactory()
	{
		if (modelPackage == null)
		{
			modelPackage = MyDslPackage.eINSTANCE;
		}
	}

	/**
	 * Returns whether this factory is applicable for the type of the object.
	 * <!-- begin-user-doc -->
	 * This implementation returns <code>true</code> if the object is either the model's package or is an instance object of the model.
	 * <!-- end-user-doc -->
	 * @return whether this factory is applicable for the type of the object.
	 * @generated
	 */
	@Override
	public boolean isFactoryForType(Object object)
	{
		if (object == modelPackage)
		{
			return true;
		}
		if (object instanceof EObject)
		{
			return ((EObject)object).eClass().getEPackage() == modelPackage;
		}
		return false;
	}

	/**
	 * The switch that delegates to the <code>createXXX</code> methods.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @generated
	 */
	protected MyDslSwitch<Adapter> modelSwitch =
		new MyDslSwitch<Adapter>()
		{
			@Override
			public Adapter caseDomainModel(DomainModel object)
			{
				return createDomainModelAdapter();
			}
			@Override
			public Adapter caseImport(Import object)
			{
				return createImportAdapter();
			}
			@Override
			public Adapter caseStatement(Statement object)
			{
				return createStatementAdapter();
			}
			@Override
			public Adapter caseBlock(Block object)
			{
				return createBlockAdapter();
			}
			@Override
			public Adapter caseVariableDeclaration(VariableDeclaration object)
			{
				return createVariableDeclarationAdapter();
			}
			@Override
			public Adapter caseExpressionStatement(ExpressionStatement object)
			{
				return createExpressionStatementAdapter();
			}
			@Override
			public Adapter caseExpression(Expression object)
			{
				return createExpressionAdapter();
			}
			@Override
			public Adapter caseAugmentedAssignment(AugmentedAssignment object)
			{
				return createAugmentedAssignmentAdapter();
			}
			@Override
			public Adapter casePostfixOperator(PostfixOperator object)
			{
				return createPostfixOperatorAdapter();
			}
			@Override
			public Adapter casePrefixOperator(PrefixOperator object)
			{
				return createPrefixOperatorAdapter();
			}
			@Override
			public Adapter caseAnonymousFunction(AnonymousFunction object)
			{
				return createAnonymousFunctionAdapter();
			}
			@Override
			public Adapter caseNumberLiteral(NumberLiteral object)
			{
				return createNumberLiteralAdapter();
			}
			@Override
			public Adapter caseStringLiteral(StringLiteral object)
			{
				return createStringLiteralAdapter();
			}
			@Override
			public Adapter caseCharLiteral(CharLiteral object)
			{
				return createCharLiteralAdapter();
			}
			@Override
			public Adapter caseVariableReference(VariableReference object)
			{
				return createVariableReferenceAdapter();
			}
			@Override
			public Adapter caseIfStatement(IfStatement object)
			{
				return createIfStatementAdapter();
			}
			@Override
			public Adapter caseForLoop(ForLoop object)
			{
				return createForLoopAdapter();
			}
			@Override
			public Adapter caseWhileLoop(WhileLoop object)
			{
				return createWhileLoopAdapter();
			}
			@Override
			public Adapter caseDoWhileLoop(DoWhileLoop object)
			{
				return createDoWhileLoopAdapter();
			}
			@Override
			public Adapter caseFunctionDeclaration(FunctionDeclaration object)
			{
				return createFunctionDeclarationAdapter();
			}
			@Override
			public Adapter caseFunctionCall(FunctionCall object)
			{
				return createFunctionCallAdapter();
			}
			@Override
			public Adapter caseFunctionReturn(FunctionReturn object)
			{
				return createFunctionReturnAdapter();
			}
			@Override
			public Adapter caseConsoleLogStatement(ConsoleLogStatement object)
			{
				return createConsoleLogStatementAdapter();
			}
			@Override
			public Adapter caseTryCatchStatement(TryCatchStatement object)
			{
				return createTryCatchStatementAdapter();
			}
			@Override
			public Adapter caseSwitchStatement(SwitchStatement object)
			{
				return createSwitchStatementAdapter();
			}
			@Override
			public Adapter caseCase(Case object)
			{
				return createCaseAdapter();
			}
			@Override
			public Adapter caseDefault(Default object)
			{
				return createDefaultAdapter();
			}
			@Override
			public Adapter caseStringManipulationStatement(StringManipulationStatement object)
			{
				return createStringManipulationStatementAdapter();
			}
			@Override
			public Adapter caseStringManipulationFunctionCall(StringManipulationFunctionCall object)
			{
				return createStringManipulationFunctionCallAdapter();
			}
			@Override
			public Adapter caseSplitFunctionCall(SplitFunctionCall object)
			{
				return createSplitFunctionCallAdapter();
			}
			@Override
			public Adapter caseJoinFunctionCall(JoinFunctionCall object)
			{
				return createJoinFunctionCallAdapter();
			}
			@Override
			public Adapter caseSliceFunctionCall(SliceFunctionCall object)
			{
				return createSliceFunctionCallAdapter();
			}
			@Override
			public Adapter caseThrowStatement(ThrowStatement object)
			{
				return createThrowStatementAdapter();
			}
			@Override
			public Adapter caseLogicalExpression(LogicalExpression object)
			{
				return createLogicalExpressionAdapter();
			}
			@Override
			public Adapter caseComparisonExpression(ComparisonExpression object)
			{
				return createComparisonExpressionAdapter();
			}
			@Override
			public Adapter caseArithmeticExpression(ArithmeticExpression object)
			{
				return createArithmeticExpressionAdapter();
			}
			@Override
			public Adapter caseMultiplicationExpression(MultiplicationExpression object)
			{
				return createMultiplicationExpressionAdapter();
			}
			@Override
			public Adapter caseExponentiationExpression(ExponentiationExpression object)
			{
				return createExponentiationExpressionAdapter();
			}
			@Override
			public Adapter caseBoolean(org.xtext.example.mydsl.myDsl.Boolean object)
			{
				return createBooleanAdapter();
			}
			@Override
			public Adapter caseNotBoolean(NotBoolean object)
			{
				return createNotBooleanAdapter();
			}
			@Override
			public Adapter defaultCase(EObject object)
			{
				return createEObjectAdapter();
			}
		};

	/**
	 * Creates an adapter for the <code>target</code>.
	 * <!-- begin-user-doc -->
	 * <!-- end-user-doc -->
	 * @param target the object to adapt.
	 * @return the adapter for the <code>target</code>.
	 * @generated
	 */
	@Override
	public Adapter createAdapter(Notifier target)
	{
		return modelSwitch.doSwitch((EObject)target);
	}


	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.DomainModel <em>Domain Model</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.DomainModel
	 * @generated
	 */
	public Adapter createDomainModelAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.Import <em>Import</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.Import
	 * @generated
	 */
	public Adapter createImportAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.Statement <em>Statement</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.Statement
	 * @generated
	 */
	public Adapter createStatementAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.Block <em>Block</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.Block
	 * @generated
	 */
	public Adapter createBlockAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.VariableDeclaration <em>Variable Declaration</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.VariableDeclaration
	 * @generated
	 */
	public Adapter createVariableDeclarationAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.ExpressionStatement <em>Expression Statement</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.ExpressionStatement
	 * @generated
	 */
	public Adapter createExpressionStatementAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.Expression <em>Expression</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.Expression
	 * @generated
	 */
	public Adapter createExpressionAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.AugmentedAssignment <em>Augmented Assignment</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.AugmentedAssignment
	 * @generated
	 */
	public Adapter createAugmentedAssignmentAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.PostfixOperator <em>Postfix Operator</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.PostfixOperator
	 * @generated
	 */
	public Adapter createPostfixOperatorAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.PrefixOperator <em>Prefix Operator</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.PrefixOperator
	 * @generated
	 */
	public Adapter createPrefixOperatorAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.AnonymousFunction <em>Anonymous Function</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.AnonymousFunction
	 * @generated
	 */
	public Adapter createAnonymousFunctionAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.NumberLiteral <em>Number Literal</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.NumberLiteral
	 * @generated
	 */
	public Adapter createNumberLiteralAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.StringLiteral <em>String Literal</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.StringLiteral
	 * @generated
	 */
	public Adapter createStringLiteralAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.CharLiteral <em>Char Literal</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.CharLiteral
	 * @generated
	 */
	public Adapter createCharLiteralAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.VariableReference <em>Variable Reference</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.VariableReference
	 * @generated
	 */
	public Adapter createVariableReferenceAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.IfStatement <em>If Statement</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.IfStatement
	 * @generated
	 */
	public Adapter createIfStatementAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.ForLoop <em>For Loop</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.ForLoop
	 * @generated
	 */
	public Adapter createForLoopAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.WhileLoop <em>While Loop</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.WhileLoop
	 * @generated
	 */
	public Adapter createWhileLoopAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.DoWhileLoop <em>Do While Loop</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.DoWhileLoop
	 * @generated
	 */
	public Adapter createDoWhileLoopAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.FunctionDeclaration <em>Function Declaration</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.FunctionDeclaration
	 * @generated
	 */
	public Adapter createFunctionDeclarationAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.FunctionCall <em>Function Call</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.FunctionCall
	 * @generated
	 */
	public Adapter createFunctionCallAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.FunctionReturn <em>Function Return</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.FunctionReturn
	 * @generated
	 */
	public Adapter createFunctionReturnAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.ConsoleLogStatement <em>Console Log Statement</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.ConsoleLogStatement
	 * @generated
	 */
	public Adapter createConsoleLogStatementAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.TryCatchStatement <em>Try Catch Statement</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.TryCatchStatement
	 * @generated
	 */
	public Adapter createTryCatchStatementAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.SwitchStatement <em>Switch Statement</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.SwitchStatement
	 * @generated
	 */
	public Adapter createSwitchStatementAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.Case <em>Case</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.Case
	 * @generated
	 */
	public Adapter createCaseAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.Default <em>Default</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.Default
	 * @generated
	 */
	public Adapter createDefaultAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.StringManipulationStatement <em>String Manipulation Statement</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.StringManipulationStatement
	 * @generated
	 */
	public Adapter createStringManipulationStatementAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.StringManipulationFunctionCall <em>String Manipulation Function Call</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.StringManipulationFunctionCall
	 * @generated
	 */
	public Adapter createStringManipulationFunctionCallAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.SplitFunctionCall <em>Split Function Call</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.SplitFunctionCall
	 * @generated
	 */
	public Adapter createSplitFunctionCallAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.JoinFunctionCall <em>Join Function Call</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.JoinFunctionCall
	 * @generated
	 */
	public Adapter createJoinFunctionCallAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.SliceFunctionCall <em>Slice Function Call</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.SliceFunctionCall
	 * @generated
	 */
	public Adapter createSliceFunctionCallAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.ThrowStatement <em>Throw Statement</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.ThrowStatement
	 * @generated
	 */
	public Adapter createThrowStatementAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.LogicalExpression <em>Logical Expression</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.LogicalExpression
	 * @generated
	 */
	public Adapter createLogicalExpressionAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.ComparisonExpression <em>Comparison Expression</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.ComparisonExpression
	 * @generated
	 */
	public Adapter createComparisonExpressionAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.ArithmeticExpression <em>Arithmetic Expression</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.ArithmeticExpression
	 * @generated
	 */
	public Adapter createArithmeticExpressionAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.MultiplicationExpression <em>Multiplication Expression</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.MultiplicationExpression
	 * @generated
	 */
	public Adapter createMultiplicationExpressionAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.ExponentiationExpression <em>Exponentiation Expression</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.ExponentiationExpression
	 * @generated
	 */
	public Adapter createExponentiationExpressionAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.Boolean <em>Boolean</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.Boolean
	 * @generated
	 */
	public Adapter createBooleanAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for an object of class '{@link org.xtext.example.mydsl.myDsl.NotBoolean <em>Not Boolean</em>}'.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null so that we can easily ignore cases;
	 * it's useful to ignore a case when inheritance will catch all the cases anyway.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @see org.xtext.example.mydsl.myDsl.NotBoolean
	 * @generated
	 */
	public Adapter createNotBooleanAdapter()
	{
		return null;
	}

	/**
	 * Creates a new adapter for the default case.
	 * <!-- begin-user-doc -->
	 * This default implementation returns null.
	 * <!-- end-user-doc -->
	 * @return the new adapter.
	 * @generated
	 */
	public Adapter createEObjectAdapter()
	{
		return null;
	}

} //MyDslAdapterFactory
