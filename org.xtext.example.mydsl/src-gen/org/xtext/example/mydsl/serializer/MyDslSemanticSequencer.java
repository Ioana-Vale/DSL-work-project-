/*
 * generated by Xtext 2.35.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myDsl.AnonymousFunction;
import org.xtext.example.mydsl.myDsl.ArithmeticExpression;
import org.xtext.example.mydsl.myDsl.Block;
import org.xtext.example.mydsl.myDsl.Case;
import org.xtext.example.mydsl.myDsl.CharLiteral;
import org.xtext.example.mydsl.myDsl.ComparisonExpression;
import org.xtext.example.mydsl.myDsl.ConsoleLogStatement;
import org.xtext.example.mydsl.myDsl.Default;
import org.xtext.example.mydsl.myDsl.DoWhileLoop;
import org.xtext.example.mydsl.myDsl.DomainModel;
import org.xtext.example.mydsl.myDsl.ExponentiationExpression;
import org.xtext.example.mydsl.myDsl.ExpressionStatement;
import org.xtext.example.mydsl.myDsl.ForLoop;
import org.xtext.example.mydsl.myDsl.FunctionCall;
import org.xtext.example.mydsl.myDsl.FunctionDeclaration;
import org.xtext.example.mydsl.myDsl.FunctionReturn;
import org.xtext.example.mydsl.myDsl.IfStatement;
import org.xtext.example.mydsl.myDsl.Import;
import org.xtext.example.mydsl.myDsl.JoinFunctionCall;
import org.xtext.example.mydsl.myDsl.LogicalExpression;
import org.xtext.example.mydsl.myDsl.MultiplicationExpression;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.NotBoolean;
import org.xtext.example.mydsl.myDsl.NumberLiteral;
import org.xtext.example.mydsl.myDsl.SliceFunctionCall;
import org.xtext.example.mydsl.myDsl.SplitFunctionCall;
import org.xtext.example.mydsl.myDsl.StringLiteral;
import org.xtext.example.mydsl.myDsl.SwitchStatement;
import org.xtext.example.mydsl.myDsl.ThrowStatement;
import org.xtext.example.mydsl.myDsl.TryCatchStatement;
import org.xtext.example.mydsl.myDsl.VariableDeclaration;
import org.xtext.example.mydsl.myDsl.VariableReference;
import org.xtext.example.mydsl.myDsl.WhileLoop;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.ANONYMOUS_FUNCTION:
				sequence_AnonymousFunction(context, (AnonymousFunction) semanticObject); 
				return; 
			case MyDslPackage.ARITHMETIC_EXPRESSION:
				sequence_ArithmeticExpression(context, (ArithmeticExpression) semanticObject); 
				return; 
			case MyDslPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case MyDslPackage.BOOLEAN:
				sequence_Boolean(context, (org.xtext.example.mydsl.myDsl.Boolean) semanticObject); 
				return; 
			case MyDslPackage.CASE:
				sequence_Case(context, (Case) semanticObject); 
				return; 
			case MyDslPackage.CHAR_LITERAL:
				sequence_CharLiteral(context, (CharLiteral) semanticObject); 
				return; 
			case MyDslPackage.COMPARISON_EXPRESSION:
				sequence_ComparisonExpression(context, (ComparisonExpression) semanticObject); 
				return; 
			case MyDslPackage.CONSOLE_LOG_STATEMENT:
				sequence_ConsoleLogStatement(context, (ConsoleLogStatement) semanticObject); 
				return; 
			case MyDslPackage.DEFAULT:
				sequence_Default(context, (Default) semanticObject); 
				return; 
			case MyDslPackage.DO_WHILE_LOOP:
				sequence_DoWhileLoop(context, (DoWhileLoop) semanticObject); 
				return; 
			case MyDslPackage.DOMAIN_MODEL:
				sequence_DomainModel(context, (DomainModel) semanticObject); 
				return; 
			case MyDslPackage.EXPONENTIATION_EXPRESSION:
				sequence_ExponentiationExpression(context, (ExponentiationExpression) semanticObject); 
				return; 
			case MyDslPackage.EXPRESSION_STATEMENT:
				sequence_ExpressionStatement(context, (ExpressionStatement) semanticObject); 
				return; 
			case MyDslPackage.FOR_LOOP:
				sequence_ForLoop(context, (ForLoop) semanticObject); 
				return; 
			case MyDslPackage.FUNCTION_CALL:
				sequence_FunctionCall(context, (FunctionCall) semanticObject); 
				return; 
			case MyDslPackage.FUNCTION_DECLARATION:
				sequence_FunctionDeclaration(context, (FunctionDeclaration) semanticObject); 
				return; 
			case MyDslPackage.FUNCTION_RETURN:
				sequence_FunctionReturn(context, (FunctionReturn) semanticObject); 
				return; 
			case MyDslPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case MyDslPackage.IMPORT:
				if (rule == grammarAccess.getImportElementRule()) {
					sequence_ImportElement(context, (Import) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getImportRule()
						|| rule == grammarAccess.getStatementRule()) {
					sequence_Import(context, (Import) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.JOIN_FUNCTION_CALL:
				sequence_JoinFunctionCall(context, (JoinFunctionCall) semanticObject); 
				return; 
			case MyDslPackage.LOGICAL_EXPRESSION:
				sequence_LogicalExpression(context, (LogicalExpression) semanticObject); 
				return; 
			case MyDslPackage.MULTIPLICATION_EXPRESSION:
				sequence_MultiplicationExpression(context, (MultiplicationExpression) semanticObject); 
				return; 
			case MyDslPackage.NOT_BOOLEAN:
				sequence_NotBoolean(context, (NotBoolean) semanticObject); 
				return; 
			case MyDslPackage.NUMBER_LITERAL:
				sequence_NumberLiteral(context, (NumberLiteral) semanticObject); 
				return; 
			case MyDslPackage.SLICE_FUNCTION_CALL:
				sequence_SliceFunctionCall(context, (SliceFunctionCall) semanticObject); 
				return; 
			case MyDslPackage.SPLIT_FUNCTION_CALL:
				sequence_SplitFunctionCall(context, (SplitFunctionCall) semanticObject); 
				return; 
			case MyDslPackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case MyDslPackage.SWITCH_STATEMENT:
				sequence_SwitchStatement(context, (SwitchStatement) semanticObject); 
				return; 
			case MyDslPackage.THROW_STATEMENT:
				sequence_ThrowStatement(context, (ThrowStatement) semanticObject); 
				return; 
			case MyDslPackage.TRY_CATCH_STATEMENT:
				sequence_TryCatchStatement(context, (TryCatchStatement) semanticObject); 
				return; 
			case MyDslPackage.VARIABLE_DECLARATION:
				sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
				return; 
			case MyDslPackage.VARIABLE_REFERENCE:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getLogicalExpressionRule()
						|| action == grammarAccess.getLogicalExpressionAccess().getLogicalExpressionLeftAction_1_0_0()
						|| rule == grammarAccess.getComparisonExpressionRule()
						|| action == grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0()
						|| rule == grammarAccess.getArithmeticExpressionRule()
						|| action == grammarAccess.getArithmeticExpressionAccess().getArithmeticExpressionLeftAction_1_0()
						|| rule == grammarAccess.getMultiplicationExpressionRule()
						|| action == grammarAccess.getMultiplicationExpressionAccess().getMultiplicationExpressionLeftAction_1_0()
						|| rule == grammarAccess.getExponentiationExpressionRule()
						|| action == grammarAccess.getExponentiationExpressionAccess().getExponentiationExpressionLeftAction_1_0()
						|| rule == grammarAccess.getPrimaryRule()
						|| rule == grammarAccess.getUnaryExpressionRule()) {
					sequence_AugmentedAssignment_VariableReference(context, (VariableReference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAugmentedAssignmentRule()) {
					sequence_AugmentedAssignment_VariableReference(context, (VariableReference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPostfixOperatorRule()
						|| rule == grammarAccess.getPrefixOperatorRule()
						|| rule == grammarAccess.getVariableReferenceRule()) {
					sequence_VariableReference(context, (VariableReference) semanticObject); 
					return; 
				}
				else break;
			case MyDslPackage.WHILE_LOOP:
				sequence_WhileLoop(context, (WhileLoop) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns AnonymousFunction
	 *     LogicalExpression returns AnonymousFunction
	 *     LogicalExpression.LogicalExpression_1_0_0 returns AnonymousFunction
	 *     ComparisonExpression returns AnonymousFunction
	 *     ComparisonExpression.ComparisonExpression_1_0 returns AnonymousFunction
	 *     ArithmeticExpression returns AnonymousFunction
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns AnonymousFunction
	 *     MultiplicationExpression returns AnonymousFunction
	 *     MultiplicationExpression.MultiplicationExpression_1_0 returns AnonymousFunction
	 *     ExponentiationExpression returns AnonymousFunction
	 *     ExponentiationExpression.ExponentiationExpression_1_0 returns AnonymousFunction
	 *     Primary returns AnonymousFunction
	 *     UnaryExpression returns AnonymousFunction
	 *     AnonymousFunction returns AnonymousFunction
	 *
	 * Constraint:
	 *     ((parameters+=ID parameters+=ID*)? body=Block)
	 * </pre>
	 */
	protected void sequence_AnonymousFunction(ISerializationContext context, AnonymousFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns ArithmeticExpression
	 *     LogicalExpression returns ArithmeticExpression
	 *     LogicalExpression.LogicalExpression_1_0_0 returns ArithmeticExpression
	 *     ComparisonExpression returns ArithmeticExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns ArithmeticExpression
	 *     ArithmeticExpression returns ArithmeticExpression
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns ArithmeticExpression
	 *     MultiplicationExpression returns ArithmeticExpression
	 *     MultiplicationExpression.MultiplicationExpression_1_0 returns ArithmeticExpression
	 *     ExponentiationExpression returns ArithmeticExpression
	 *     ExponentiationExpression.ExponentiationExpression_1_0 returns ArithmeticExpression
	 *     Primary returns ArithmeticExpression
	 *     UnaryExpression returns ArithmeticExpression
	 *
	 * Constraint:
	 *     (left=ArithmeticExpression_ArithmeticExpression_1_0 right=MultiplicationExpression)
	 * </pre>
	 */
	protected void sequence_ArithmeticExpression(ISerializationContext context, ArithmeticExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ARITHMETIC_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ARITHMETIC_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.ARITHMETIC_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.ARITHMETIC_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArithmeticExpressionAccess().getArithmeticExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getArithmeticExpressionAccess().getRightMultiplicationExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns VariableReference
	 *     LogicalExpression returns VariableReference
	 *     LogicalExpression.LogicalExpression_1_0_0 returns VariableReference
	 *     ComparisonExpression returns VariableReference
	 *     ComparisonExpression.ComparisonExpression_1_0 returns VariableReference
	 *     ArithmeticExpression returns VariableReference
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns VariableReference
	 *     MultiplicationExpression returns VariableReference
	 *     MultiplicationExpression.MultiplicationExpression_1_0 returns VariableReference
	 *     ExponentiationExpression returns VariableReference
	 *     ExponentiationExpression.ExponentiationExpression_1_0 returns VariableReference
	 *     Primary returns VariableReference
	 *     UnaryExpression returns VariableReference
	 *
	 * Constraint:
	 *     (name=[VariableDeclaration|ID] expr=Expression?)
	 * </pre>
	 */
	protected void sequence_AugmentedAssignment_VariableReference(ISerializationContext context, VariableReference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	// This method is commented out because it has the same signature as another method in this class.
	// This is probably a bug in Xtext's serializer, please report it here: 
	// https://bugs.eclipse.org/bugs/enter_bug.cgi?product=TMF
	//
	// Contexts:
	//     AugmentedAssignment returns VariableReference
	//
	// Constraint:
	//     (name=[VariableDeclaration|ID] expr=Expression)
	//
	// protected void sequence_AugmentedAssignment_VariableReference(ISerializationContext context, VariableReference semanticObject) { }
	
	/**
	 * <pre>
	 * Contexts:
	 *     Block returns Block
	 *
	 * Constraint:
	 *     statements+=Statement+
	 * </pre>
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns Boolean
	 *     LogicalExpression returns Boolean
	 *     LogicalExpression.LogicalExpression_1_0_0 returns Boolean
	 *     ComparisonExpression returns Boolean
	 *     ComparisonExpression.ComparisonExpression_1_0 returns Boolean
	 *     ArithmeticExpression returns Boolean
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns Boolean
	 *     MultiplicationExpression returns Boolean
	 *     MultiplicationExpression.MultiplicationExpression_1_0 returns Boolean
	 *     ExponentiationExpression returns Boolean
	 *     ExponentiationExpression.ExponentiationExpression_1_0 returns Boolean
	 *     Primary returns Boolean
	 *     UnaryExpression returns Boolean
	 *     Boolean returns Boolean
	 *
	 * Constraint:
	 *     (value='true' | value='false' | value='null')
	 * </pre>
	 */
	protected void sequence_Boolean(ISerializationContext context, org.xtext.example.mydsl.myDsl.Boolean semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Case returns Case
	 *
	 * Constraint:
	 *     (value=Expression statements+=Statement*)
	 * </pre>
	 */
	protected void sequence_Case(ISerializationContext context, Case semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns CharLiteral
	 *     LogicalExpression returns CharLiteral
	 *     LogicalExpression.LogicalExpression_1_0_0 returns CharLiteral
	 *     ComparisonExpression returns CharLiteral
	 *     ComparisonExpression.ComparisonExpression_1_0 returns CharLiteral
	 *     ArithmeticExpression returns CharLiteral
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns CharLiteral
	 *     MultiplicationExpression returns CharLiteral
	 *     MultiplicationExpression.MultiplicationExpression_1_0 returns CharLiteral
	 *     ExponentiationExpression returns CharLiteral
	 *     ExponentiationExpression.ExponentiationExpression_1_0 returns CharLiteral
	 *     Primary returns CharLiteral
	 *     UnaryExpression returns CharLiteral
	 *     CharLiteral returns CharLiteral
	 *
	 * Constraint:
	 *     value=CHAR
	 * </pre>
	 */
	protected void sequence_CharLiteral(ISerializationContext context, CharLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CHAR_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CHAR_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCharLiteralAccess().getValueCHARTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns ComparisonExpression
	 *     LogicalExpression returns ComparisonExpression
	 *     LogicalExpression.LogicalExpression_1_0_0 returns ComparisonExpression
	 *     ComparisonExpression returns ComparisonExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns ComparisonExpression
	 *     ArithmeticExpression returns ComparisonExpression
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns ComparisonExpression
	 *     MultiplicationExpression returns ComparisonExpression
	 *     MultiplicationExpression.MultiplicationExpression_1_0 returns ComparisonExpression
	 *     ExponentiationExpression returns ComparisonExpression
	 *     ExponentiationExpression.ExponentiationExpression_1_0 returns ComparisonExpression
	 *     Primary returns ComparisonExpression
	 *     UnaryExpression returns ComparisonExpression
	 *
	 * Constraint:
	 *     (left=ComparisonExpression_ComparisonExpression_1_0 right=ArithmeticExpression)
	 * </pre>
	 */
	protected void sequence_ComparisonExpression(ISerializationContext context, ComparisonExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.COMPARISON_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.COMPARISON_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.COMPARISON_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.COMPARISON_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonExpressionAccess().getRightArithmeticExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns ConsoleLogStatement
	 *     ConsoleLogStatement returns ConsoleLogStatement
	 *
	 * Constraint:
	 *     (arguments+=Expression arguments+=Expression*)?
	 * </pre>
	 */
	protected void sequence_ConsoleLogStatement(ISerializationContext context, ConsoleLogStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Default returns Default
	 *
	 * Constraint:
	 *     statements+=Statement*
	 * </pre>
	 */
	protected void sequence_Default(ISerializationContext context, Default semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns DoWhileLoop
	 *     DoWhileLoop returns DoWhileLoop
	 *
	 * Constraint:
	 *     (body=Block condition=Expression)
	 * </pre>
	 */
	protected void sequence_DoWhileLoop(ISerializationContext context, DoWhileLoop semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DO_WHILE_LOOP__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DO_WHILE_LOOP__BODY));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.DO_WHILE_LOOP__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.DO_WHILE_LOOP__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDoWhileLoopAccess().getBodyBlockParserRuleCall_1_0(), semanticObject.getBody());
		feeder.accept(grammarAccess.getDoWhileLoopAccess().getConditionExpressionParserRuleCall_4_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DomainModel returns DomainModel
	 *
	 * Constraint:
	 *     statements+=Statement+
	 * </pre>
	 */
	protected void sequence_DomainModel(ISerializationContext context, DomainModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns ExponentiationExpression
	 *     LogicalExpression returns ExponentiationExpression
	 *     LogicalExpression.LogicalExpression_1_0_0 returns ExponentiationExpression
	 *     ComparisonExpression returns ExponentiationExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns ExponentiationExpression
	 *     ArithmeticExpression returns ExponentiationExpression
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns ExponentiationExpression
	 *     MultiplicationExpression returns ExponentiationExpression
	 *     MultiplicationExpression.MultiplicationExpression_1_0 returns ExponentiationExpression
	 *     ExponentiationExpression returns ExponentiationExpression
	 *     ExponentiationExpression.ExponentiationExpression_1_0 returns ExponentiationExpression
	 *     Primary returns ExponentiationExpression
	 *     UnaryExpression returns ExponentiationExpression
	 *
	 * Constraint:
	 *     (left=ExponentiationExpression_ExponentiationExpression_1_0 right=Primary)
	 * </pre>
	 */
	protected void sequence_ExponentiationExpression(ISerializationContext context, ExponentiationExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXPONENTIATION_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXPONENTIATION_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXPONENTIATION_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXPONENTIATION_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExponentiationExpressionAccess().getExponentiationExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExponentiationExpressionAccess().getRightPrimaryParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns ExpressionStatement
	 *     ExpressionStatement returns ExpressionStatement
	 *
	 * Constraint:
	 *     expr=Expression
	 * </pre>
	 */
	protected void sequence_ExpressionStatement(ISerializationContext context, ExpressionStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.EXPRESSION_STATEMENT__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.EXPRESSION_STATEMENT__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionStatementAccess().getExprExpressionParserRuleCall_0_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns ForLoop
	 *     ForLoop returns ForLoop
	 *
	 * Constraint:
	 *     (initialization=Expression condition=Expression increment=Expression body=Block)
	 * </pre>
	 */
	protected void sequence_ForLoop(ISerializationContext context, ForLoop semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FOR_LOOP__INITIALIZATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FOR_LOOP__INITIALIZATION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FOR_LOOP__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FOR_LOOP__CONDITION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FOR_LOOP__INCREMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FOR_LOOP__INCREMENT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FOR_LOOP__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FOR_LOOP__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForLoopAccess().getInitializationExpressionParserRuleCall_2_0(), semanticObject.getInitialization());
		feeder.accept(grammarAccess.getForLoopAccess().getConditionExpressionParserRuleCall_4_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getForLoopAccess().getIncrementExpressionParserRuleCall_6_0(), semanticObject.getIncrement());
		feeder.accept(grammarAccess.getForLoopAccess().getBodyBlockParserRuleCall_8_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns FunctionCall
	 *     FunctionCall returns FunctionCall
	 *
	 * Constraint:
	 *     (name=[FunctionDeclaration|ID] (arguments+=Expression arguments+=Expression*)?)
	 * </pre>
	 */
	protected void sequence_FunctionCall(ISerializationContext context, FunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns FunctionDeclaration
	 *     FunctionDeclaration returns FunctionDeclaration
	 *
	 * Constraint:
	 *     (returnType=Type? name=ID (parameters+=ID parameters+=ID*)? body=Block)
	 * </pre>
	 */
	protected void sequence_FunctionDeclaration(ISerializationContext context, FunctionDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns FunctionReturn
	 *     FunctionReturn returns FunctionReturn
	 *
	 * Constraint:
	 *     expr=Expression
	 * </pre>
	 */
	protected void sequence_FunctionReturn(ISerializationContext context, FunctionReturn semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FUNCTION_RETURN__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FUNCTION_RETURN__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionReturnAccess().getExprExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns IfStatement
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (condition=Expression thenBranch=Block elseBranch=Block?)
	 * </pre>
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ImportElement returns Import
	 *
	 * Constraint:
	 *     ((element=ID | element='*' | element=STRING) alias=ID?)
	 * </pre>
	 */
	protected void sequence_ImportElement(ISerializationContext context, Import semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Import returns Import
	 *     Statement returns Import
	 *
	 * Constraint:
	 *     ((importedElement+=ImportElement? (importedElements+=ImportElement importedElements+=ImportElement*)?)+ importURI=STRING)
	 * </pre>
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns JoinFunctionCall
	 *     StringManipulationStatement returns JoinFunctionCall
	 *     StringManipulationFunctionCall returns JoinFunctionCall
	 *     JoinFunctionCall returns JoinFunctionCall
	 *
	 * Constraint:
	 *     (str+=Expression str+=Expression* delimiter=StringLiteral)
	 * </pre>
	 */
	protected void sequence_JoinFunctionCall(ISerializationContext context, JoinFunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns LogicalExpression
	 *     LogicalExpression returns LogicalExpression
	 *     LogicalExpression.LogicalExpression_1_0_0 returns LogicalExpression
	 *     ComparisonExpression returns LogicalExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns LogicalExpression
	 *     ArithmeticExpression returns LogicalExpression
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns LogicalExpression
	 *     MultiplicationExpression returns LogicalExpression
	 *     MultiplicationExpression.MultiplicationExpression_1_0 returns LogicalExpression
	 *     ExponentiationExpression returns LogicalExpression
	 *     ExponentiationExpression.ExponentiationExpression_1_0 returns LogicalExpression
	 *     Primary returns LogicalExpression
	 *     UnaryExpression returns LogicalExpression
	 *
	 * Constraint:
	 *     (left=LogicalExpression_LogicalExpression_1_0_0 right=ComparisonExpression)
	 * </pre>
	 */
	protected void sequence_LogicalExpression(ISerializationContext context, LogicalExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LOGICAL_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LOGICAL_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LOGICAL_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LOGICAL_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogicalExpressionAccess().getLogicalExpressionLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getLogicalExpressionAccess().getRightComparisonExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns MultiplicationExpression
	 *     LogicalExpression returns MultiplicationExpression
	 *     LogicalExpression.LogicalExpression_1_0_0 returns MultiplicationExpression
	 *     ComparisonExpression returns MultiplicationExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns MultiplicationExpression
	 *     ArithmeticExpression returns MultiplicationExpression
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns MultiplicationExpression
	 *     MultiplicationExpression returns MultiplicationExpression
	 *     MultiplicationExpression.MultiplicationExpression_1_0 returns MultiplicationExpression
	 *     ExponentiationExpression returns MultiplicationExpression
	 *     ExponentiationExpression.ExponentiationExpression_1_0 returns MultiplicationExpression
	 *     Primary returns MultiplicationExpression
	 *     UnaryExpression returns MultiplicationExpression
	 *
	 * Constraint:
	 *     (left=MultiplicationExpression_MultiplicationExpression_1_0 right=ExponentiationExpression)
	 * </pre>
	 */
	protected void sequence_MultiplicationExpression(ISerializationContext context, MultiplicationExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.MULTIPLICATION_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.MULTIPLICATION_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.MULTIPLICATION_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.MULTIPLICATION_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicationExpressionAccess().getMultiplicationExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicationExpressionAccess().getRightExponentiationExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns NotBoolean
	 *     LogicalExpression returns NotBoolean
	 *     LogicalExpression.LogicalExpression_1_0_0 returns NotBoolean
	 *     ComparisonExpression returns NotBoolean
	 *     ComparisonExpression.ComparisonExpression_1_0 returns NotBoolean
	 *     ArithmeticExpression returns NotBoolean
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns NotBoolean
	 *     MultiplicationExpression returns NotBoolean
	 *     MultiplicationExpression.MultiplicationExpression_1_0 returns NotBoolean
	 *     ExponentiationExpression returns NotBoolean
	 *     ExponentiationExpression.ExponentiationExpression_1_0 returns NotBoolean
	 *     Primary returns NotBoolean
	 *     UnaryExpression returns NotBoolean
	 *     NotBoolean returns NotBoolean
	 *
	 * Constraint:
	 *     value=NOT
	 * </pre>
	 */
	protected void sequence_NotBoolean(ISerializationContext context, NotBoolean semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.NOT_BOOLEAN__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.NOT_BOOLEAN__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotBooleanAccess().getValueNOTTerminalRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns NumberLiteral
	 *     LogicalExpression returns NumberLiteral
	 *     LogicalExpression.LogicalExpression_1_0_0 returns NumberLiteral
	 *     ComparisonExpression returns NumberLiteral
	 *     ComparisonExpression.ComparisonExpression_1_0 returns NumberLiteral
	 *     ArithmeticExpression returns NumberLiteral
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns NumberLiteral
	 *     MultiplicationExpression returns NumberLiteral
	 *     MultiplicationExpression.MultiplicationExpression_1_0 returns NumberLiteral
	 *     ExponentiationExpression returns NumberLiteral
	 *     ExponentiationExpression.ExponentiationExpression_1_0 returns NumberLiteral
	 *     Primary returns NumberLiteral
	 *     UnaryExpression returns NumberLiteral
	 *     NumberLiteral returns NumberLiteral
	 *
	 * Constraint:
	 *     value=NUMBER
	 * </pre>
	 */
	protected void sequence_NumberLiteral(ISerializationContext context, NumberLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.NUMBER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.NUMBER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberLiteralAccess().getValueNUMBERParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns SliceFunctionCall
	 *     StringManipulationStatement returns SliceFunctionCall
	 *     StringManipulationFunctionCall returns SliceFunctionCall
	 *     SliceFunctionCall returns SliceFunctionCall
	 *
	 * Constraint:
	 *     (str=Expression start=INT end=INT)
	 * </pre>
	 */
	protected void sequence_SliceFunctionCall(ISerializationContext context, SliceFunctionCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SLICE_FUNCTION_CALL__STR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SLICE_FUNCTION_CALL__STR));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SLICE_FUNCTION_CALL__START) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SLICE_FUNCTION_CALL__START));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SLICE_FUNCTION_CALL__END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SLICE_FUNCTION_CALL__END));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSliceFunctionCallAccess().getStrExpressionParserRuleCall_2_0(), semanticObject.getStr());
		feeder.accept(grammarAccess.getSliceFunctionCallAccess().getStartINTTerminalRuleCall_4_0(), semanticObject.getStart());
		feeder.accept(grammarAccess.getSliceFunctionCallAccess().getEndINTTerminalRuleCall_6_0(), semanticObject.getEnd());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns SplitFunctionCall
	 *     StringManipulationStatement returns SplitFunctionCall
	 *     StringManipulationFunctionCall returns SplitFunctionCall
	 *     SplitFunctionCall returns SplitFunctionCall
	 *
	 * Constraint:
	 *     (str=Expression delimiter=StringLiteral)
	 * </pre>
	 */
	protected void sequence_SplitFunctionCall(ISerializationContext context, SplitFunctionCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SPLIT_FUNCTION_CALL__STR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SPLIT_FUNCTION_CALL__STR));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SPLIT_FUNCTION_CALL__DELIMITER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SPLIT_FUNCTION_CALL__DELIMITER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSplitFunctionCallAccess().getStrExpressionParserRuleCall_2_0(), semanticObject.getStr());
		feeder.accept(grammarAccess.getSplitFunctionCallAccess().getDelimiterStringLiteralParserRuleCall_4_0(), semanticObject.getDelimiter());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Expression returns StringLiteral
	 *     LogicalExpression returns StringLiteral
	 *     LogicalExpression.LogicalExpression_1_0_0 returns StringLiteral
	 *     ComparisonExpression returns StringLiteral
	 *     ComparisonExpression.ComparisonExpression_1_0 returns StringLiteral
	 *     ArithmeticExpression returns StringLiteral
	 *     ArithmeticExpression.ArithmeticExpression_1_0 returns StringLiteral
	 *     MultiplicationExpression returns StringLiteral
	 *     MultiplicationExpression.MultiplicationExpression_1_0 returns StringLiteral
	 *     ExponentiationExpression returns StringLiteral
	 *     ExponentiationExpression.ExponentiationExpression_1_0 returns StringLiteral
	 *     Primary returns StringLiteral
	 *     UnaryExpression returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns SwitchStatement
	 *     SwitchStatement returns SwitchStatement
	 *
	 * Constraint:
	 *     (expression=Expression cases+=Case* defaultCase=Default?)
	 * </pre>
	 */
	protected void sequence_SwitchStatement(ISerializationContext context, SwitchStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns ThrowStatement
	 *     ThrowStatement returns ThrowStatement
	 *
	 * Constraint:
	 *     expr=Expression
	 * </pre>
	 */
	protected void sequence_ThrowStatement(ISerializationContext context, ThrowStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.THROW_STATEMENT__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.THROW_STATEMENT__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getThrowStatementAccess().getExprExpressionParserRuleCall_1_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns TryCatchStatement
	 *     TryCatchStatement returns TryCatchStatement
	 *
	 * Constraint:
	 *     (tryBlock=Block exception=ID catchBlock=Block)
	 * </pre>
	 */
	protected void sequence_TryCatchStatement(ISerializationContext context, TryCatchStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TRY_CATCH_STATEMENT__TRY_BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TRY_CATCH_STATEMENT__TRY_BLOCK));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TRY_CATCH_STATEMENT__EXCEPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TRY_CATCH_STATEMENT__EXCEPTION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TRY_CATCH_STATEMENT__CATCH_BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TRY_CATCH_STATEMENT__CATCH_BLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTryCatchStatementAccess().getTryBlockBlockParserRuleCall_1_0(), semanticObject.getTryBlock());
		feeder.accept(grammarAccess.getTryCatchStatementAccess().getExceptionIDTerminalRuleCall_4_0(), semanticObject.getException());
		feeder.accept(grammarAccess.getTryCatchStatementAccess().getCatchBlockBlockParserRuleCall_6_0(), semanticObject.getCatchBlock());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns VariableDeclaration
	 *     VariableDeclaration returns VariableDeclaration
	 *
	 * Constraint:
	 *     (type=Type name=ID expr=Expression?)
	 * </pre>
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, VariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PostfixOperator returns VariableReference
	 *     PrefixOperator returns VariableReference
	 *     VariableReference returns VariableReference
	 *
	 * Constraint:
	 *     name=[VariableDeclaration|ID]
	 * </pre>
	 */
	protected void sequence_VariableReference(ISerializationContext context, VariableReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.VARIABLE_REFERENCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.VARIABLE_REFERENCE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableReferenceAccess().getNameVariableDeclarationIDTerminalRuleCall_0_1(), semanticObject.eGet(MyDslPackage.Literals.VARIABLE_REFERENCE__NAME, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns WhileLoop
	 *     WhileLoop returns WhileLoop
	 *
	 * Constraint:
	 *     (condition=Expression body=Block)
	 * </pre>
	 */
	protected void sequence_WhileLoop(ISerializationContext context, WhileLoop semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.WHILE_LOOP__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.WHILE_LOOP__CONDITION));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.WHILE_LOOP__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.WHILE_LOOP__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileLoopAccess().getConditionExpressionParserRuleCall_2_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getWhileLoopAccess().getBodyBlockParserRuleCall_4_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
}
